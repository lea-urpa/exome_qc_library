"""
Functions for annotating samples in a matrix table with Hail.

Author: Lea Urpa, August 2020
"""
import logging
import hail as hl


def annotate_cols_from_file(mt, file, args):
    """
    Takes a matrix table, a file with sample information, and annotates the cols of the matrix table with each column
    in the given file. File can be hail table, as long as the file ends with .ht it is detected and read.

    :param mt: matrix table with columns keyed with variable 's'
    :param file: text file to import with hl.import_table, or hail table to read with hl.read_table.
    :param args: arguments to get samples files delimiter, column with sample IDs, and missing data value.
    :return:
    """
    if not file.endswith(".ht"):
        ht = hl.import_table(file, delimiter=args.samples_delim, impute=True, key=args.samples_col,
                             missing=args.samples_miss)
    else:
        ht = hl.read_table(file)

    mt = mt.annotate_cols(**ht[mt.s])

    return mt


def annotate_relateds(mt, relateds_to_remove_file):
    """
    Annotates a matrix table, given a list of individuals (single column, no header) that are related to remove from
    subsequent analysis. Does not remove the individuals- simply marks them as 'True' in the variable
    'related_to_remove'

    :param mt: matrix table to annotate
    :param relateds_to_remove_file: file containing IDs of individuals to remove from analyses needing independent cases
    :return: returns annotated matrix table with new column variable 'related_to_remove'
    """
    # Import list of related individuals to remove, generated by python code/networkx
    relatives = hl.import_table(relateds_to_remove_file, no_header=True)
    relatives = relatives.annotate(related_to_remove=True)
    relatives = relatives.key_by('f0')

    # Annotate matrix table with relatives to remove
    mt = mt.annotate_cols(related_to_remove=relatives[mt.s].related_to_remove)
    mt = mt.annotate_cols(related_to_remove=hl.or_else(mt.related_to_remove, False))

    return mt


def sex_aware_sample_annotations(mt, mt_to_annotate, args):
    """
    Creates sex-aware sample annotations for call rate

    :param mt: Matrix table where failing samples and variants have been filtered out
    :param mt_to_annotate: matrix table to copy the annotation to, without samples filtered out
    :return: Returns non-filtered matrix table with additional column annotation sexaware_sample_call_rate
    """
    logging.info(f"Annotating sex aware sample call rate using column {args.sex_col}")
    num_y_non_par_vars = mt.aggregate_rows(hl.agg.count_where(mt.locus.in_y_nonpar()))
    num_all_other_vars = mt.aggregate_rows(hl.agg.count_where(~mt.locus.in_y_nonpar()))

    mt = mt.annotate_cols(sexaware_sample_call_rate=(hl.case()
                                                     .when(mt[args.sex_col] == args.female_tag,
                                                           hl.agg.count_where(hl.is_defined(mt.GT) &
                                                                              ~mt.locus.in_y_nonpar()) /
                                                           num_all_other_vars)
                                                     .default(hl.agg.count_where(hl.is_defined(mt.GT)) /
                                                              (num_y_non_par_vars + num_all_other_vars))))

    mt_to_annotate = mt_to_annotate.annotate_cols(sexaware_sample_call_rate=
                                                  mt.cols()[mt_to_annotate.s].sexaware_sample_call_rate)

    return mt_to_annotate
